(defNew &private 
    [
        &prop :String directory
        &prop :String inExtension
        &prop :String outExtension
        &prop :String outBlockTerminator
        &prop :Array<Block> blocks
        // TODO store an array of undo history i.e. EditBlock(id, inFrom, inTo, outFrom, outTo)
        //                                          InsertBlock(idx, id)
        //                                          EditBlockStatus(id, status),
    ]
    [
        :String inFile "${directory}/$(.withoutExtension (directory.withoutDirectory)).${inExtension}"
        :String outFile "${directory}/$(.withoutExtension (directory.withoutDirectory)).${outExtension}"
        :String blockDir "${directory}/blocks"
        :String tctFile "${directory}/tct.txt"
    ])

(function :FileConversionProject loadDirectory [directory]
    (let [tctFile "${directory}/tct.txt"
            stream (Stream.fromFile tctFile)
            [inExtension outExtension outBlockTerminator]
                (for thing ["inExtension" "outExtension" "outBlockTerminator"]
                    (stream.expect thing ->(stream.takeUntilAndDrop "|||")))
            blockLines
                {
                    (stream.dropWhitespace)
                    (filter (stream.content.split "\n"))
                }]
        
        (new FileConversionProject directory inExtension outExtension outBlockTerminator
            (for blockLine blockLines
                (let [[id lockedStr] (blockLine.split " ")]
                    (object
                        id id
                        locked (= lockedStr "true")
                        inText (File.getContent "${directory}/blocks/${id}.${inExtension}")
                        outText (File.getContent "${directory}/blocks/${id}.${outExtension}")))))))

(function importFile [:String inFile :String outExtension :String inBlockDelimiter :String outBlockTerminator]
    (let [inExtension (inFile.extension)
            content (File.getContent inFile)
            inBlockContent (content.split inBlockDelimiter)]
        (.fullSave
            (new FileConversionProject
                "$(inFile.withoutExtension).tct"
                inExtension
                outExtension
                outBlockTerminator
                (for [idx section] (enumerate inBlockContent)
                    (when (= idx (- inBlockContent.length 1))
                        (set inBlockDelimiter ""))
                    (object 
                        id (Uuid.v4)
                        inText "${section}${inBlockDelimiter}"
                        outText ""
                        locked false))))))

(method :Void saveTctFile []
    (let [&mut tctContent ""]
        (+= tctContent "${inExtension}|||${outExtension}|||${outBlockTerminator}|||\n")
        (doFor block blocks
            (+= tctContent "${block.id} ${block.locked}\n")
            (File.saveContent tctFile tctContent))))

(method :Void saveBlock [:Block block]
    (File.saveContent "${blockDir}/${block.id}.${inExtension}" block.inText)
    (File.saveContent "${blockDir}/${block.id}.${outExtension}" block.outText))

(method :FileConversionProject fullSave []
    (unless (and (FileSystem.exists directory) (FileSystem.isDirectory directory))
        (FileSystem.createDirectory directory))

    (unless (and (FileSystem.exists blockDir) (FileSystem.isDirectory blockDir))
        (FileSystem.createDirectory blockDir))

    (saveTctFile)

    (doFor block blocks
        (saveBlock block))

    (File.saveContent inFile
        (.join (for block blocks block.inText) ""))

    (File.saveContent outFile
        (.join (for block blocks block.outText) ""))

    this)

(prop :Array<ChangeRecord> changeHistory [])
(prop &mut :Array<ChangeRecord> undoHistory [])

// TODO undoChange
// TODO redoChange

(method applyChange [:ChangeRecord change]
    (case change
        ((objectWith [type Insert] blockIndex newBlock)
            (blocks.insert blockIndex newBlock)
            (saveTctFile)
            (saveBlock newBlock))
        (never otherwise))
    (changeHistory.push change))

(method insertBlock [index &opt :String inText :String outText block :Bool locked]
    (applyChange (object
                    type Insert
                    blockIndex index
                    newBlock (object
                                id (Uuid.v4)
                                inText (or inText "")
                                outText (or outText "")
                                locked ?locked))))